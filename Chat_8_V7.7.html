<!--
State of the Code (as of 2025-08-07):

This is a single-page application (SPA) for a chat interface that interacts with an n8n backend.

**CURRENT STATUS:**


Core Functionality:
1.  **Project Launcher**: On startup, the user can either create a new project or continue an existing one.
2.  **Project Creation**:
    - Simple: Creates a project with a name, generating a `project_id` and a `session_id`. (WORKING)
    - From URL: Creates a project and performs an initial data indexing from a provided JSON URL, generating a `project_id`, `session_id`, and `rag_session_id`. (WORKING)
3.  **Continue Project**:
    - Fetches a list of existing projects from the backend.
    - Populates a dropdown. When a project is selected, it should load the corresponding `project_id`, `session_id`, and `rag_session_id` into the application's state. (BUGGY)
4.  **Chat Interface**:
    - Once a project is active, the user can chat. Messages are sent to the backend with the current `project_id`, `chat_session_id`, and `rag_session_id`.
    - Supports "Committing to Memory," which sends the conversation history to a specific backend workflow to be summarized and stored in a RAG store. The backend returns an updated `rag_session_id`.
5.  **State Management**:
    - The application state (current IDs) is held in global JavaScript variables (`currentProjectId`, `currentChatId`, `currentRagId`).
    - This state is persisted across page reloads using `sessionStorage`.
    - The primary bug is in the `handleProjectSelection` function, where the `rag_session_id` is not being correctly retrieved and set from the dropdown's `dataset`, leading to failed RAG lookups.

Backend Endpoints (n8n webhooks):
- SETUP_WORKFLOW_URL: For creating simple projects.
- LIST_PROJECTS_URL: For listing existing projects.
- RAG_INDEXING_WORKFLOW_URL: For creating projects from a URL and indexing data.
- CHAT_WORKFLOW_URL: For handling chat messages.
- COMMIT_MEMORY_WORKFLOW_URL: For committing conversation history to memory.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Chat 8 v7</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        body { font-family: Arial, sans-serif; background: #f4f4f4; margin: 0; padding: 20px; }
        #chat-container { max-width: 1400px; margin: 40px auto; background: #fff; border-radius: 8px; box-shadow: 0 2px 8px #ccc; padding: 20px; position: relative; } /* Added position: relative */

        #session-controls { margin-bottom: 15px; display: flex; gap: 10px; align-items: center;}
        #sessionSelect { padding: 8px; border-radius: 4px; flex-grow: 1; }
        #session-controls button { padding: 8px 12px; border-radius: 4px; border: 1px solid #ccc; background-color: #f0f0f0; cursor: pointer; white-space: nowrap; }
        #session-controls button:hover { background-color: #e0e0e0; }

        /* --- Chat Window Flexbox Layout --- */
        #chat {
          min-height: 350px;
          max-height: 450px;
          min-width: 300px;
          max-width: 100%;
          overflow-y: auto;
          margin-bottom: 15px;
          border: 1px solid #ccc;
          border-radius: 6px;
          padding: 10px;
          background: #fafafa;
          resize: vertical;
          box-sizing: border-box;
        }

        /* --- Base Message Bubble Style --- */
        .message {
          max-width: 80%;
          padding: 8px 12px;
          border-radius: 16px;
          margin: 8px 0;
          line-height: 1.4;
          word-wrap: break-word;
          display: inline-block;
        }

        /* --- AI (Bot) Message Style (Chat 7 style) --- */
        .bot-message {
          background: #e8f5e9;
          color: #388e3c;
          float: left;
          clear: both;
          text-align: left;
          border-bottom-left-radius: 4px;
        }

        /* --- User Message Style (Chat 7 style) --- */
        .user-message {
          background: #e3f2fd;
          color: #1976d2;
          float: right;
          clear: both;
          text-align: right;
          border-bottom-right-radius: 4px;
        }

        #input-row { display: flex; gap: 10px; margin-top: 10px; align-items: flex-start; }
        #chat-input { flex: 1; padding: 10px; border-radius: 4px; border: 1px solid #ccc; resize: both; /* Allow both horizontal and vertical resizing */ min-height: 40px; box-sizing: border-box; }
        #send, #mic { padding: 10px 15px; border-radius: 4px; border: 1px solid #ccc; background-color: #f0f0f0; cursor: pointer; height: 40px; box-sizing: border-box;}
        #send:hover, #mic:hover { background-color: #e0e0e0; }
        #recording { color: red; font-size: 0.9em; margin-left: 10px; align-self: center; }
        #file-management { display: flex; gap: 10px; margin-top: 10px; }
        #file-upload button { padding: 8px 12px; border-radius: 4px; border: 1px solid #ccc; background-color: #f0f0f0; cursor: pointer; }
        #file-upload button:hover { background-color: #e0e0f0; }
        #drop-area { flex-grow: 1; border: 2px dashed #bbb; border-radius: 8px; padding: 20px; text-align: center; color: #888; background: #f9f9f9; }
        #drop-area.dragover { border-color: #1976d2; background: #e3f2fd; color: #1976d2; }
        
        #preview { margin-top: 10px; text-align: center; }
        #preview img { max-width: 150px; max-height: 150px; display: block; margin: 5px auto; border: 1px solid #ddd; }
        #preview p { font-size: 0.9em; color: #555; margin: 4px 0; }
        #preview button { background-color: #f8f9fa; border: 1px solid #ced4da; padding: 5px 10px; cursor: pointer; font-size: 0.8em; }

        /* --- NEW - This positions the version display correctly in the bottom right corner --- */
        #version-display {
            position: absolute;
            bottom: 5px;
            right: 15px;
            font-size: 0.75em;
            color: #888;
            display: block;
        }
    /* Debug tray to compare webhook JSON vs. bubble text */
    #debug-tray { display:none; background:#fff7e6; border:1px solid #f0ad4e; border-radius:6px; padding:10px; margin-top:10px; font-family: Consolas, monospace; font-size:12px; max-height:180px; overflow:auto; }
    #debug-toggle { cursor:pointer; color:#8a6d3b; font-size:12px; margin-left:8px; }

        /* --- NEW - Styling for the hidden version popup --- */
        .modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 95%;
            max-width: 820px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .modal-content label { display: block; margin-bottom: 10px; }
        .modal-content input { width: calc(100% - 20px); padding: 8px; margin-bottom: 15px; }
        .modal-content button { padding: 8px 16px; cursor: pointer; }
    /* Persona Editor sizing */
    #persona-editor { max-height: 360px; overflow: auto; }
    .persona-row { background:#fafafa; }
    .persona-row .pe-key { min-width: 160px; }
    .persona-row .pe-label { min-width: 260px; }

        /* --- Progress Bar for AI Response (Animated Segment + Label, improved offset) --- */
        #progress-bar {
          display: none;
          position: relative;
          height: 24px;
          width: 100%;
          margin-bottom: 8px;
          background: none;
        }
        #progress-bar-label {
          position: absolute;
          left: 0;
          top: 0;
          height: 100%;
          display: flex;
          align-items: center;
          font-size: 0.95em;
          color: #1976d2;
          font-weight: bold;
          padding-left: 8px;
          z-index: 2;
          pointer-events: none;
        }
        #progress-bar-indicator {
          position: absolute;
          left: 180px; /* Increased offset to clear label */
          top: 10px;
          height: 4px;
          width: 120px;
          background: linear-gradient(90deg, #1976d2 0%, #42a5f5 100%);
          border-radius: 2px;
          animation: progressBarMove 1.2s linear infinite;
          z-index: 1;
        }
        @keyframes progressBarMove {
          0% { left: 180px; width: 0; opacity: 0.7; }
          20% { left: 180px; width: 60px; opacity: 1; }
          50% { left: 210px; width: 120px; opacity: 1; }
          80% { left: 350px; width: 60px; opacity: 1; }
          100% { left: 430px; width: 0; opacity: 0.7; }
        }

        /* --- Dashboard Styles --- */
        #dashboard-container {
          display: none;
          max-width: 1400px;
          margin: 40px auto;
          background: #fff;
          border-radius: 8px;
          box-shadow: 0 2px 8px #ccc;
          padding: 24px 20px 20px 20px;
        }
        .dashboard-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 24px;
        }
        .dashboard-title {
          font-size: 2em;
          font-weight: bold;
          color: #1976d2;
        }
        .dashboard-close {
          background: #e0e0e0;
          border: none;
          border-radius: 4px;
          padding: 8px 16px;
          font-size: 1em;
          cursor: pointer;
        }
        .dashboard-close:hover {
          background: #bdbdbd;
        }
        .project-card {
          background: #f9f9f9;
          border: 1px solid #e0e0e0;
          border-radius: 8px;
          margin-bottom: 24px;
          padding: 18px 20px 16px 20px;
          box-shadow: 0 1px 4px #eee;
        }
        .project-card h2 {
          margin: 0 0 8px 0;
          color: #1976d2;
        }
        .project-status {
          font-weight: bold;
          color: #388e3c;
          margin-bottom: 6px;
        }
        .project-synopsis {
          margin-bottom: 10px;
          color: #444;
        }
        .backlog-section {
          margin-bottom: 8px;
        }
        .backlog-section h3 {
          margin: 8px 0 4px 0;
          font-size: 1.1em;
          color: #333;
        }
        .backlog-section ul {
          margin: 0 0 0 18px;
          padding: 0;
        }
        .backlog-section li {
          margin-bottom: 3px;
        }

        #project-list-loader {
          display: none;
          padding: 10px;
          color: #555;
        }

                /* --- Toast Notification --- */
                #toast {
                    position: absolute;
                    top: 12px;
                    right: 12px;
                    background: #323232;
                    color: #fff;
                    padding: 10px 14px;
                    border-radius: 6px;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                    display: none;
                    z-index: 999;
                    font-size: 0.95em;
                    max-width: 60%;
                }
                #toast.success { background: #2e7d32; }
                #toast.info { background: #1976d2; }
                #toast.error { background: #c62828; }
    </style>
</head>
<body>

  <!-- Project Launcher and Containers -->
  <div id="project-launcher">
    <h2>Project Selector</h2>
    <p>Please choose an option to begin.</p>
    <button id="createProjectButton">Start New Project</button>
    <button id="continueProjectButton">Continue Existing Project</button>
  </div>

  <div id="project-list-container" style="display: none;">
    <h2>Existing Projects</h2>
    <div id="project-list">
      <div id="project-list-loader">Loading projects, please wait...</div>
      <div id="project-selection-ui">
        <label for="project-select-dropdown">Select a project to continue:</label>
        <select id="project-select-dropdown"></select>
      </div>
      
    </div>
  </div>

  <div id="new-project-container" style="display: none;">
    <h2>Create New Project</h2>

    <!-- Step 1: Ask the user for the type of project -->
    <div id="new-project-choice">
        <p>Will this project be created from a JSON data source (URL)?</p>
        <button id="new-project-choice-yes">Yes, from URL</button>
        <button id="new-project-choice-no">No, create empty project</button>
    </div>

    <!-- Step 2 (Path A): Simple project creation -->
    <div id="new-project-simple" style="display: none;">
        <label for="new-project-name-input">Project Name:</label>
        <input type="text" id="new-project-name-input" placeholder="Enter Project Name...">
    <label for="persona-select-simple">Persona (system prompt):</label>
    <select id="persona-select-simple"></select>
        <button id="createNewProjectConfirmButton">Create Project</button>
    </div>

    <!-- Step 2 (Path B): Create project from JSON URL -->
    <div id="new-project-from-url" style="display: none;">
        <label for="new-project-json-url">Enter JSON URL:</label>
        <input type="text" id="new-project-json-url" placeholder="https://example.com/data.json">
        <label for="new-project-name-from-url">Enter Project Name:</label>
        <input type="text" id="new-project-name-from-url" placeholder="Enter Project Name...">
    <label for="persona-select-url">Persona (system prompt):</label>
    <select id="persona-select-url"></select>
        <button id="createNewProjectFromUrlConfirmButton">Create Project and Index Data</button>
        <div id="status-message" style="margin-top:10px; color:#1976d2; font-size:0.95em;"></div>
    </div>
  </div>

  <!-- DASHBOARD CONTAINER (hidden by default) -->
  <div id="dashboard-container" class="hidden">
    <div class="dashboard-header">
      <span class="dashboard-title">Project Dashboard</span>
      <button class="dashboard-close" id="dashboard-close-btn">Back to Chat</button>
    </div>
    <div id="dashboard-content"></div>
  </div>

  <div id="chat-container">
    
    <div id="progress-bar">
      <span id="progress-bar-label">Waiting for response:</span>
      <span id="progress-bar-indicator"></span>
    </div>
    <!-- This is the single, correct set of session controls -->
    <div id="session-controls">
        <select id="sessionSelect"></select>
        <button id="new-session-button">New Session</button>
        <button id="clear-chat-button">Clear Chat</button>
        <button id="delete-session-button">Delete Session</button>
        <button id="dashboard-btn">Dashboard</button>
        <button id="commit-btn">Bootstrap Memory</button>
    <button id="config-btn">Config</button>
    </div>
    
    <div id="chat"></div>

    <div id="input-row">
        <textarea id="chat-input" placeholder="Type your message, paste an image, or add an image..." rows="2"></textarea>
        <button id="mic" onclick="startVoice()" title="Voice Input">🎤</button>
        <button id="send-button">Send</button>
        <button id="commit-memory-btn">Commit to Memory</button>
        <span id="recording" style="display:none;">Recording...</span>
    </div>

    <div id="file-management">
        <div id="file-upload">
            <input type="file" id="fileInput" style="display:none;" onchange="handleFileSelect(event)" accept="image/*" />
            <button onclick="document.getElementById('fileInput').click()">Upload Image</button>
        </div>
        <div id="drop-area">Or drag & drop an image here</div>
    </div>
    <input type="file" id="jsonIndexInput" style="display:none;" accept=".json,application/json" />

    <div id="preview"></div>

    <!-- This is the version display, now correctly positioned by the CSS above -->
    <div id="version-display" class="version-display"></div>
    <span id="debug-toggle" title="Show last payload/response">[debug]</span>

    <!-- Toast container -->
    <div id="toast" class="info"></div>
    <div id="debug-tray"></div>
    
  </div>

  <!-- --- NEW - This is the hidden popup window for setting the version --- -->
  <div id="version-modal" class="modal hidden">
      <div class="modal-content">
          <label for="new-version-input">Enter new version text:</label>
          <input type="text" id="new-version-input" placeholder="e.g., Chat 8 v4">
          <button id="version-ok">OK</button>
      </div>
  </div>

    <!-- Config Modal -->
    <div id="config-modal" class="modal hidden">
            <div class="modal-content">
                    <h3>Configuration</h3>
                    <label>
                        <input type="checkbox" id="cfg-show-toasts">
                        Show commit toasts
                    </label>
                    <label title="Auto-commit is currently controlled in the workflow; toggle coming soon.">
                        <input type="checkbox" id="cfg-auto-commit" disabled>
                        Auto-commit on messages starting with "remember …" (coming soon)
                    </label>
                    <hr/>
                    <div>
                        <h4>Persona Editor</h4>
                        <p style="margin:6px 0 10px 0; font-size: 12px; color: #555;">Add, edit, or hide personas. Custom personas are stored locally and override defaults by key.</p>
                        <div id="persona-editor"></div>
                        <button id="persona-add" type="button">Add Persona</button>
                    </div>
                    <div style="display:flex; gap:10px; justify-content:flex-end;">
                        <button id="config-cancel">Close</button>
                        <button id="config-save">Save</button>
                    </div>
            </div>
    </div>
    
<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- STAGE 1: CONFIGURATION & STATE (Define ALL variables first) ---

    // URLs
    const SETUP_WORKFLOW_URL = 'https://mhcmike.app.n8n.cloud/webhook/d0b91f11-487b-441f-80a3-17edd5a703db';
    const LIST_PROJECTS_URL = 'https://mhcmike.app.n8n.cloud/webhook/a61a290c-d8e5-4c04-980a-4ebb415a21e4';
    const RAG_INDEXING_WORKFLOW_URL = 'https://mhcmike.app.n8n.cloud/webhook/303639ed-a3e2-4eae-b406-16e1c6200a81';
    const CHAT_WORKFLOW_URL = 'https://mhcmike.app.n8n.cloud/webhook/3c92075f-a856-439a-b70d-73f3c847f8fa';
    const COMMIT_MEMORY_WORKFLOW_URL = 'https://mhcmike.app.n8n.cloud/webhook/6c1ce608-2f7a-457b-9afc-f0be5ef4bd4c';

    // State Variables
    let currentChatId = null;
    let currentProjectId = null;
    let currentRagId = null;
    let sessions = {};
    let currentImageData = null;
    let lastCommitMessageCount = 0;
    let showCommitToasts = true;

    // DOM Element References
    const startScreen = document.getElementById('project-launcher');
    const projectListContainer = document.getElementById('project-list-container');
    const newProjectFormsContainer = document.getElementById('new-project-container');
    const newProjectChoiceContainer = document.getElementById('new-project-choice');
    const newProjectSimpleDiv = document.getElementById('new-project-simple');
    const newProjectFromUrlDiv = document.getElementById('new-project-from-url');
    const mainChatContainer = document.getElementById('chat-container');
    const chat = document.getElementById('chat');
    const chatInput = document.getElementById('chat-input');
    const projectSelectDropdown = document.getElementById('project-select-dropdown');
    const statusMessage = document.getElementById('status-message');
    const dashboardContainer = document.getElementById('dashboard-container');
    const dashboardContent = document.getElementById('dashboard-content');
    const versionDisplay = document.getElementById('version-display');
    const sessionSelect = document.getElementById('sessionSelect');
    
    // Buttons and Inputs
    const continueProjectButton = document.getElementById('continueProjectButton');
    const createProjectButton = document.getElementById('createProjectButton'); // This is the CORRECT ID for "Start New Project"
    const newProjectChoiceYes = document.getElementById('new-project-choice-yes');
    const newProjectChoiceNo = document.getElementById('new-project-choice-no');
    const newProjectNameInput = document.getElementById('new-project-name-input');
    const createSimpleProjectButton = document.getElementById('createNewProjectConfirmButton');
    const createIndexProjectButton = document.getElementById('createIndexProjectBtn');
    const commitMemoryButton = document.getElementById('commit-memory-btn');
    const sendButton = document.getElementById('send-button');
    const clearSessionButton = document.getElementById('clear-chat-button');
    const dashboardBtn = document.getElementById('dashboard-btn');
    const dashboardCloseBtn = document.getElementById('dashboard-close-btn');
    const configBtn = document.getElementById('config-btn');
    const configModal = document.getElementById('config-modal');
    const cfgShowToasts = document.getElementById('cfg-show-toasts');
    const cfgAutoCommit = document.getElementById('cfg-auto-commit');
    const cfgSave = document.getElementById('config-save');
    const cfgCancel = document.getElementById('config-cancel');
    const toastEl = document.getElementById('toast');
    const createProjectFromUrlButton = document.getElementById('createNewProjectFromUrlConfirmButton');
    const newProjectJsonUrlInput = document.getElementById('new-project-json-url');
    const newProjectNameFromUrlInput = document.getElementById('new-project-name-from-url');
    const personaSelectSimple = document.getElementById('persona-select-simple');
    const personaSelectUrl = document.getElementById('persona-select-url');
    const personaAddBtn = document.getElementById('persona-add');
    const progressBar = document.getElementById('progress-bar');
    const progressBarLabel = document.getElementById('progress-bar-label');
    const debugToggle = document.getElementById('debug-toggle');
    const debugTray = document.getElementById('debug-tray');


    // --- STAGE 2: CORE FUNCTIONS (Define ALL functions next) ---

    function addMessage(sender, text, isHtml = false) {
        const messageElement = document.createElement('div');
        messageElement.classList.add('message', `${sender}-message`);
        if (isHtml) {
            messageElement.innerHTML = text;
        } else {
            messageElement.textContent = text;
        }
        chat.appendChild(messageElement);
        chat.scrollTop = chat.scrollHeight;
        return messageElement;
    }

    // Personas: defaults + optional custom set from localStorage.
    const DEFAULT_PERSONAS = [
        { key: 'dev_assistant', label: 'Developer Assistant (A)', content: 'You are a concise developer assistant. Return the smallest correct answer. Prefer code-only when obvious. No flourish.', active: true },
        { key: 'biz_analyst', label: 'Business Analyst (B)', content: 'You are a concise business analyst. Answer in brief bullets. No fluff. Use the user\'s terms.', active: true },
        { key: 'facts_extractor', label: 'Facts Extractor (Default)', content: 'You extract terse facts. Only verifiable statements. Respond minimally.', active: true }
    ];

    function loadCustomPersonas() {
        try {
            const raw = localStorage.getItem('custom_personas_v1');
            if (!raw) return [];
            const arr = JSON.parse(raw);
            if (!Array.isArray(arr)) return [];
            return arr.filter(p => p && typeof p.key === 'string' && typeof p.label === 'string' && typeof p.content === 'string')
                      .map(p => ({ ...p, active: p.active !== false }));
        } catch { return []; }
    }

    function saveCustomPersonas(arr) {
        try { localStorage.setItem('custom_personas_v1', JSON.stringify(arr || [])); } catch {}
    }

    function getAllPersonas() {
        // Merge by key: custom overrides defaults; keep only active=true.
        const byKey = {};
        DEFAULT_PERSONAS.forEach(p => { if (p && p.key) byKey[p.key] = { ...p }; });
        loadCustomPersonas().forEach(p => { if (p && p.key) byKey[p.key] = { ...p }; });
        return Object.values(byKey).filter(p => p.active !== false);
    }

    function populatePersonaDropdown(selectEl) {
        if (!selectEl) return;
        selectEl.innerHTML = '';
        const personas = getAllPersonas();
        personas.forEach((p, i) => {
            const opt = document.createElement('option');
            opt.value = p.key;
            opt.textContent = p.label;
            if (i === 0) opt.selected = true;
            selectEl.appendChild(opt);
        });
    }

    function personaKeyToContent(key) {
        const all = getAllPersonas();
        const p = all.find(x => x.key === key);
        return p ? p.content : (all[0]?.content || '');
    }

    // Persona editor rendering (shows defaults + custom overrides)
    function renderPersonaEditor() {
        const container = document.getElementById('persona-editor');
        if (!container) return;
        // Derive editor rows: include defaults and apply custom overrides by key
        const customs = loadCustomPersonas();
        const byKey = {};
        DEFAULT_PERSONAS.forEach(p => { byKey[p.key] = { ...p, __isDefault: true }; });
        customs.forEach(p => { byKey[p.key] = { ...byKey[p.key], ...p, __isDefault: false }; });
        const rows = Object.values(byKey);
        const mkRow = (p, idx) => `
            <div class="persona-row" data-index="${idx}" style="border:1px solid #ddd; padding:8px; margin-bottom:8px;">
                <div style=\"display:flex; gap:10px; align-items:center;\">
                    <label style=\"min-width:50px;\">Key</label>
                    <input class=\"pe-key\" type=\"text\" ${p.__isDefault ? 'readonly title=\\"Default keys cannot be changed; create a new persona to override.\\"' : ''} value=\"${(p.key||'').replace(/\\\"/g,'&quot;')}\" placeholder=\"unique_key\" style=\"flex:1;\"/>
                    <label style=\"min-width:50px;\">Label</label>
                    <input class=\"pe-label\" type=\"text\" value=\"${(p.label||'').replace(/\\\"/g,'&quot;')}\" placeholder=\"Display label\" style=\"flex:2;\"/>
                    <label title=\"If unchecked, persona is hidden from dropdowns.\">
                        <input class=\"pe-active\" type=\"checkbox\" ${p.active === false ? '' : 'checked'} /> Active
                    </label>
                    <button type=\"button\" class=\"pe-delete\" ${p.__isDefault ? 'disabled title=\\"Defaults cannot be deleted; override by key instead.\\"' : ''}>Delete</button>
                </div>
                <div style=\"margin-top:6px;\">
                    <textarea class=\"pe-content\" rows=\"4\" style=\"width:100%;\" placeholder=\"System prompt content...\">${(p.content||'').replace(/</g,'&lt;')}</textarea>
                </div>
            </div>`;
        container.innerHTML = rows.map((p, i) => mkRow(p, i)).join('');
        // Wire delete buttons to remove from custom store only
        container.querySelectorAll('.pe-delete').forEach((btn, i) => {
            btn.addEventListener('click', () => {
                const key = container.querySelectorAll('.persona-row')[i].querySelector('.pe-key')?.value;
                if (!key) return;
                const arr = loadCustomPersonas().filter(p => p.key !== key);
                saveCustomPersonas(arr);
                renderPersonaEditor();
            });
        });
    }

    function addPersonaRow() {
        const arr = loadCustomPersonas();
        arr.push({ key: '', label: '', content: '', active: true });
        saveCustomPersonas(arr);
        renderPersonaEditor();
    }

    // Collect only custom personas (diff vs defaults) to save
    function collectPersonaEditor() {
        const container = document.getElementById('persona-editor');
        if (!container) return loadCustomPersonas();
        const rows = Array.from(container.querySelectorAll('.persona-row'));
        const out = [];
        rows.forEach(row => {
            const key = row.querySelector('.pe-key')?.value?.trim();
            const label = row.querySelector('.pe-label')?.value?.trim();
            const content = row.querySelector('.pe-content')?.value ?? '';
            const active = row.querySelector('.pe-active')?.checked !== false;
            if (!key) return;
            const def = DEFAULT_PERSONAS.find(d => d.key === key);
            const candidate = { key, label: label || '', content: content || '', active };
            if (!def) {
                // brand-new persona
                if (label && content) out.push(candidate);
                return;
            }
            // only save if different from default
            const changed = (def.label !== candidate.label) || (def.content !== candidate.content) || (def.active !== candidate.active);
            if (changed) out.push(candidate);
        });
        return out;
    }

    // Persist per-project persona choice locally; server mapping optional.
    function saveProjectPersona(projectId, personaKey) {
        if (!projectId || !personaKey) return;
        try {
            const map = JSON.parse(localStorage.getItem('project_personas') || '{}');
            map[projectId] = personaKey;
            localStorage.setItem('project_personas', JSON.stringify(map));
        } catch {}
    }
    function loadProjectPersona(projectId) {
        try {
            const map = JSON.parse(localStorage.getItem('project_personas') || '{}');
            return map[projectId] || null;
        } catch { return null; }
    }

    function saveState() {
        // Save the active IDs to sessionStorage
        sessionStorage.setItem('lastChatId_v2', currentChatId);
        sessionStorage.setItem('lastRagId_v2', currentRagId);
        sessionStorage.setItem('lastProjectId_v2', currentProjectId);

        // Safety check: Always stringify sessions, never store a plain object
        let sessionsToStore = sessions;
        if (typeof sessionsToStore !== 'string') {
            try {
                sessionsToStore = JSON.stringify(sessionsToStore);
            } catch (e) {
                console.error('Failed to stringify sessions object:', e);
                sessionsToStore = '{}';
            }
        }
        sessionStorage.setItem('chatSessions_v2', sessionsToStore);
    }

    function loadState() {
        try {
            // Get all items from sessionStorage
            const savedChatId = sessionStorage.getItem('lastChatId_v2');
            const savedRagId = sessionStorage.getItem('lastRagId_v2');
            const savedProjectId = sessionStorage.getItem('lastProjectId_v2');
            const savedSessions = sessionStorage.getItem('chatSessions_v2');

            // Check for the '[object Object]' corruption bug
            if ([savedChatId, savedRagId, savedProjectId, savedSessions].includes('[object Object]')) {
                throw new Error("Corrupted '[object Object]' string found in sessionStorage.");
            }

            // Restore state if the items exist
            if (savedChatId) currentChatId = savedChatId;
            // Allow ragId to be null
            currentRagId = savedRagId || null; 
            if (savedProjectId) currentProjectId = savedProjectId;
            if (savedSessions) sessions = JSON.parse(savedSessions);

        } catch (error) {
            // Safety net: If anything goes wrong, log it, wipe storage, and reset state.
            console.error("Corrupted or invalid state detected. Clearing storage and resetting.", error);
            sessionStorage.clear();
            currentChatId = null;
            currentProjectId = null;
            currentRagId = null;
            sessions = {};
        }
    }
    
    function updateStatus(message, isError = false) {
        statusMessage.textContent = message;
        statusMessage.style.color = isError ? 'red' : '#1976d2';
        statusMessage.style.display = message ? 'block' : 'none';
    }

    function showToast(msg, type = 'info', timeoutMs = 3000) {
        if (!showCommitToasts || !toastEl) return;
        toastEl.className = '';
        toastEl.classList.add(type);
        toastEl.id = 'toast';
        toastEl.textContent = msg;
        toastEl.style.display = 'block';
        clearTimeout(showToast._t);
        showToast._t = setTimeout(() => {
            toastEl.style.display = 'none';
        }, timeoutMs);
    }

    function openConfig() {
        cfgShowToasts.checked = !!showCommitToasts;
        configModal.style.display = 'block';
    configModal.classList.remove('hidden');
    renderPersonaEditor();
    }

    function closeConfig() {
        configModal.style.display = 'none';
        configModal.classList.add('hidden');
    }

    function loadConfig() {
        try {
            const v = localStorage.getItem('cfg_show_toasts');
            if (v !== null) showCommitToasts = v === 'true';
        } catch {}
    }

    function saveConfig() {
        showCommitToasts = !!cfgShowToasts.checked;
        try { localStorage.setItem('cfg_show_toasts', String(showCommitToasts)); } catch {}
        // Persist personas from editor
        const edited = collectPersonaEditor();
        // ensure unique by key (last wins)
        const seen = new Set();
        const dedup = [];
        for (let i = edited.length - 1; i >= 0; i--) {
            const p = edited[i];
            if (!seen.has(p.key)) { seen.add(p.key); dedup.unshift(p); }
        }
        saveCustomPersonas(dedup);
        // Refresh persona dropdowns
        populatePersonaDropdown(personaSelectSimple);
        populatePersonaDropdown(personaSelectUrl);
        closeConfig();
        showToast('Settings saved', 'info', 1500);
    }

    // Lightweight progress helpers (reuse top progress bar)
    function showProgress(label = 'Working...') {
        try {
            if (progressBarLabel) progressBarLabel.textContent = label;
            if (progressBar) progressBar.style.display = 'block';
        } catch {}
    }
    function hideProgress() {
        try {
            if (progressBar) progressBar.style.display = 'none';
        } catch {}
    }

    // Lightweight debug helpers
    function setDebug(payload, responseMetaOrBody) {
        if (!debugTray) return;
        const payloadStr = typeof payload === 'string' ? payload : JSON.stringify(payload, null, 2);
        let metaShown;
        try {
            if (responseMetaOrBody && typeof responseMetaOrBody === 'object' && ('status' in responseMetaOrBody || 'headers' in responseMetaOrBody || 'body' in responseMetaOrBody)) {
                metaShown = JSON.stringify(responseMetaOrBody, null, 2);
            } else {
                metaShown = JSON.stringify(responseMetaOrBody, null, 2);
            }
        } catch { metaShown = String(responseMetaOrBody); }
        debugTray.innerText = `Last payload ->\n${payloadStr}\n\nLast response <-\n${metaShown}`;
    }
    if (debugToggle) {
        debugToggle.addEventListener('click', () => {
            if (!debugTray) return;
            debugTray.style.display = (debugTray.style.display === 'block') ? 'none' : 'block';
        });
    }

    // Robust fetch with timeout and a single retry for transient network errors
    async function fetchWithTimeout(url, options = {}, timeoutMs = 45000) {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeoutMs);
        try {
            const resp = await fetch(url, { ...options, signal: controller.signal });
            clearTimeout(id);
            return resp;
        } catch (err) {
            clearTimeout(id);
            throw err;
        }
    }

    async function fetchJsonWithRetry(url, options = {}, timeoutMs = 45000) {
        try {
            const resp = await fetchWithTimeout(url, options, timeoutMs);
            return resp;
        } catch (err) {
            // Retry once on transient network failure
            const msg = String(err?.message || err);
            if (msg.includes('Failed to fetch') || err?.name === 'AbortError' || msg.includes('NetworkError')) {
                await new Promise(r => setTimeout(r, 800));
                return fetchWithTimeout(url, options, timeoutMs);
            }
            throw err;
        }
    }

    // Read JSON safely even if servers occasionally return text/html or plain text.
    async function readJsonSafe(response) {
        try {
            const ct = response.headers.get('content-type') || '';
            if (ct.includes('application/json') || ct.includes('application/vnd.api+json')) {
                return await response.json();
            }
            // Fallback: read as text and best-effort parse
            const text = await response.text();
            try {
                if (text && (text.trim().startsWith('{') || text.trim().startsWith('['))) {
                    return JSON.parse(text);
                }
            } catch {}
            return text;
        } catch (e) {
            // As a final fallback, return empty object to avoid crashing callers
            console.warn('readJsonSafe: failed to parse response as JSON. Returning empty object.', e);
            return {};
        }
    }

    function setSession(chatId, ragId, projectName, projectId) {
        // Set the live global state variables
        currentChatId = chatId;
        currentRagId = ragId;
        currentProjectId = projectId;

        // Update the sessions object for local history
        if (!sessions[chatId]) {
            sessions[chatId] = { history: [], projectName: projectName };
        }
        sessions[chatId].projectName = projectName;
    }

    async function handleCreateIndexProject() {
        const jsonUrl = newProjectJsonUrlInput.value.trim();
        const projectName = newProjectNameFromUrlInput.value.trim();
        const personaKey = (personaSelectUrl && personaSelectUrl.value) || (getAllPersonas()[0]?.key || 'facts_extractor');

        if (!jsonUrl || !projectName) {
            alert('Please enter both a JSON URL and a project name.');
            return;
        }

        updateStatus(`Creating project "${projectName}" and indexing data from URL...`);

        try {
            const response = await fetch(RAG_INDEXING_WORKFLOW_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    projectName: projectName,
                    jsonUrl: jsonUrl,
                    // Optional: if backend supports prompt mapping at create time
                    persona_key: personaKey
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Network response was not ok (${response.status}): ${errorText}`);
            }

            const data = await response.json();
            console.log('Received data from RAG Indexing workflow:', data);

            if (data.project_id && data.session_id && data.rag_session_id) {
                setSession(data.session_id, data.rag_session_id, projectName, data.project_id);
                saveProjectPersona(data.project_id, personaKey);
                saveState();

                newProjectFormsContainer.style.display = 'none';
                mainChatContainer.style.display = 'block';
                populateSessionSelector();
                updateStatus('', false);
                chat.innerHTML = '';
                const personaLabel = (getAllPersonas().find(p=>p.key===personaKey)?.label) || personaKey;
                addMessage('bot', `Project "${projectName}" created and data indexed successfully. Persona: ${personaLabel}.`, true);
            } else {
                throw new Error('Workflow response was missing required IDs (project_id, session_id, or rag_session_id).');
            }
        } catch (error) {
            console.error('Error during project creation from URL:', error);
            updateStatus(error.message, true);
        }
    }
    
    function initializeUI() {
        startScreen.style.display = 'none';
        projectListContainer.style.display = 'none';
        newProjectFormsContainer.style.display = 'none';
        mainChatContainer.style.display = 'none';

        if (currentChatId && currentProjectId) {
            mainChatContainer.style.display = 'block';
            const sessionName = sessions[currentChatId]?.projectName || 'Current Session';
            addMessage('bot', `Resumed session for project "${sessionName}".`, true);
        } else {
            startScreen.style.display = 'block';
        }
    }

    async function handleCreateSimpleProject() {
        console.log('Starting handleCreateSimpleProject...');
        const projectName = newProjectNameInput.value.trim();
        const personaKey = (personaSelectSimple && personaSelectSimple.value) || (getAllPersonas()[0]?.key || 'facts_extractor');
        if (!projectName) { alert('Please enter a project name.'); return; }
        
        updateStatus(`Creating new project "${projectName}"...`);
        
        try {
            const response = await fetch(SETUP_WORKFLOW_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ projectName: projectName, persona_key: personaKey })
            });
            if (!response.ok) { throw new Error(`Network response was not ok (${response.status})`); }
            
            const data = await response.json();
            console.log('Received data from Create Project workflow:', data);
            
            if (data.project_id && data.session_id) {
                // For simple projects, there is no RAG ID initially.
                setSession(data.session_id, null, projectName, data.project_id);
                saveProjectPersona(data.project_id, personaKey);
                saveState();
                
                newProjectFormsContainer.style.display = 'none';
                mainChatContainer.style.display = 'block';
                populateSessionSelector(); // Refresh the project list
                updateStatus('', false);
                chat.innerHTML = ''; 
                const personaLabel = (getAllPersonas().find(p=>p.key===personaKey)?.label) || personaKey;
                addMessage('bot', `Project "${projectName}" created successfully. Persona: ${personaLabel}.`, true);
            } else { throw new Error('Workflow response was missing project_id or session_id.'); }
        } catch (error) {
            console.error('Error during simple project creation:', error);
            updateStatus(error.message, true);
        }
    }
    
    let isSending = false;
    let requestSeq = 0; // increment per send to ignore stale responses
    async function sendMessage(e) {
        if (e) e.preventDefault();
        const message = chatInput.value.trim();
        if (!message || !currentChatId) return;
        if (isSending) return; // avoid concurrent sends
        isSending = true;
        if (sendButton) sendButton.disabled = true;

        addMessage('user', message, false);
        chatInput.value = '';
        
        let thinkingIndicator = addMessage('bot', '...', false);
        thinkingIndicator.classList.add('thinking');

        showProgress('Waiting for response...');

        const myReqId = ++requestSeq;

        const payload = {
            chatInput: message,
            chat_session_id: currentChatId,
            project_id: currentProjectId,
            rag_session_id: currentRagId,
            imageData: currentImageData,
            client_req_id: myReqId,
            // Inject system prompt content from local persona selection if present
            system_prompt_content: (() => {
                const key = loadProjectPersona(currentProjectId);
                return key ? personaKeyToContent(key) : undefined;
            })()
        };

        console.log('Sending payload to CHAT_WORKFLOW_URL:', JSON.stringify(payload, null, 2));

        try {
            const chatUrl = CHAT_WORKFLOW_URL + '?_ts=' + Date.now();
            const response = await fetchJsonWithRetry(chatUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
                cache: 'no-store'
            });
            if (!response.ok) {
                let bodyText = '';
                try { bodyText = await response.text(); } catch {}
                throw new Error(`HTTP ${response.status}${bodyText ? `: ${bodyText.slice(0,180)}` : ''}`);
            }

            const data = await readJsonSafe(response);
            console.log('CHAT response JSON:', data);
            // Collect headers for debug
            const headersObj = {};
            try { response.headers.forEach((v, k) => { headersObj[k] = v; }); } catch {}
            setDebug(payload, { status: response.status, headers: headersObj, body: data });

            // Ignore stale/out-of-order responses
            if (myReqId !== requestSeq) {
                console.warn('Stale response ignored. myReqId=', myReqId, 'latest=', requestSeq);
                return;
            }

            // Prefer explicit reply; fall back to common shapes if needed
            let reply = undefined;
            if (data && typeof data === 'object') {
                reply = data.reply
                     ?? data.text
                     ?? data.message
                     ?? (Array.isArray(data.choices) && data.choices[0]?.message?.content)
                     ?? (typeof data.output_text === 'string' ? data.output_text : undefined);
            } else if (typeof data === 'string') {
                reply = data;
            }

            if (!reply) {
                console.warn('No reply field in response. Raw response:', data);
                reply = '[No reply returned from server]';
            }

            // Replace the typing indicator IN PLACE to avoid stray/stale bubbles
            try {
                thinkingIndicator.textContent = reply;
                thinkingIndicator.classList.remove('thinking');
            } catch {
                addMessage('bot', reply, false);
            }

            // If backend provided a toast (e.g., auto-commit), show it
            if (data.toast) {
                showToast(data.toast, 'success');
            }
        } catch (error) {
            console.error('Error sending message:', error);
            const emsg = (error?.name === 'AbortError') ? 'Request timed out. Please try again.' : (error?.message || 'Network error');
            try {
                thinkingIndicator.textContent = `Error: ${emsg}`;
                thinkingIndicator.classList.remove('thinking');
                thinkingIndicator.style.color = 'red';
            } catch {}
        } finally {
            hideProgress();
            isSending = false;
            if (sendButton) sendButton.disabled = false;
        }
    }

    async function commitToMemory() {
        console.log('Commit to Memory called.');
        const allMessages = Array.from(chat.querySelectorAll('.message'));
        const newMessages = allMessages.slice(lastCommitMessageCount);
        if (newMessages.length === 0) { alert('No new messages to commit.'); return; }

        const messagesToCommit = newMessages.map(msgElement => {
            const role = msgElement.classList.contains('user-message') ? 'user' : 'assistant';
            return {
                role: role,
                content: msgElement.textContent
            };
        });
        
        // UI: indicate work in progress and prevent double-clicks
        const originalBtnText = commitMemoryButton ? commitMemoryButton.textContent : '';
        if (commitMemoryButton) {
            commitMemoryButton.disabled = true;
            commitMemoryButton.textContent = 'Working...';
        }
    showProgress('Committing to memory...');
        updateStatus('Committing to memory...');
        
        try {
            const response = await fetchJsonWithRetry(COMMIT_MEMORY_WORKFLOW_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chat_session_id: currentChatId,
                    project_id: currentProjectId,
                    rag_session_id: currentRagId, // Pass current RAG ID
                    history: messagesToCommit
                }),
                cache: 'no-store'
            }, 120000); // allow up to 120s for commit to finish
            if (!response.ok) { throw new Error(`Commit failed: ${await response.text()}`); }
            
            // Be tolerant to non-JSON (some gateways strip JSON on success)
            const data = await readJsonSafe(response);

            // The workflow should return the definitive RAG ID. Trust it and update state.
            if (data.rag_session_id) {
                if (data.rag_session_id !== currentRagId) {
                    console.log(`RAG Session ID updated from ${currentRagId} to ${data.rag_session_id}`);
                    currentRagId = data.rag_session_id;
                    saveState(); // Persist the new RAG ID immediately
                }
            }

            lastCommitMessageCount = allMessages.length;
            // Prefer toast/status_line if provided
            if (data.toast) {
                showToast(data.toast, 'success');
            } else {
                showToast('Memory committed successfully!', 'success');
            }
            if (data.status_line) {
                addMessage('bot', data.status_line);
            }
            // Success UI state
            hideProgress();
            updateStatus('', false);
            if (commitMemoryButton) {
                commitMemoryButton.textContent = 'Commit Successful';
                setTimeout(() => {
                    commitMemoryButton.textContent = originalBtnText || 'Commit to Memory';
                    commitMemoryButton.disabled = false;
                }, 5000);
            }
        } catch (error) {
            console.error('Error committing memory:', error);
            hideProgress();
            const timedOut = (error?.name === 'AbortError');
            const msg = String(error?.message || '');
            const netErr = msg.includes('Failed to fetch') || msg.includes('NetworkError') || msg.includes('TypeError');
            if (timedOut || netErr) {
                updateStatus('Commit is still processing in the background. It should complete shortly.', false);
                showToast('Commit is still processing in the background.', 'info');
                if (commitMemoryButton) {
                    commitMemoryButton.textContent = 'Processing in background';
                    setTimeout(() => {
                        commitMemoryButton.textContent = originalBtnText || 'Commit to Memory';
                        commitMemoryButton.disabled = false;
                    }, 5000);
                }
            } else {
                updateStatus(error.message, true);
                showToast('Commit failed', 'error');
                if (commitMemoryButton) {
                    commitMemoryButton.textContent = 'Commit Failed';
                    setTimeout(() => {
                        commitMemoryButton.textContent = originalBtnText || 'Commit to Memory';
                        commitMemoryButton.disabled = false;
                    }, 5000);
                }
            }
        }
    }

    async function handleContinueClick() {
        // --- THE FINAL FIX: Ensure state is loaded before proceeding ---
        loadState();
        startScreen.style.display = 'none';
        projectListContainer.style.display = 'block';
        const loader = document.getElementById('project-list-loader');
        loader.style.display = 'block';
        projectSelectDropdown.style.display = 'none'; // Hide dropdown until populated
        try {
            const response = await fetch(LIST_PROJECTS_URL, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                action: 'list_projects' 
              })
            });
            if (!response.ok) { throw new Error(`Failed to fetch projects: ${response.statusText}`); }
            const data = await response.json(); // Get the full object { "projects": [...] }
            populateProjectList(data.projects); // Pass the array inside to the function
            loader.style.display = 'none';
            projectSelectDropdown.style.display = 'block';
        } catch (error) {
            console.error('Error loading projects:', error);
            loader.textContent = `Error: ${error.message}`;
            loader.style.color = 'red';
        }
    }

    function populateProjectList(projects) {
        projectSelectDropdown.innerHTML = '<option value="">-- Select a Project --</option>';
        if (projects && projects.length > 0) {
            projects.forEach(project => {
                const option = document.createElement('option');
                option.value = project.project_id;
                option.textContent = project.project_name;
                
                // Embed ALL required IDs into the dataset for later retrieval
                option.dataset.sessionId = project.session_id || ''; 
                option.dataset.ragSessionId = project.rag_session_id || ''; 

                projectSelectDropdown.appendChild(option);
            });
        } else {
            projectSelectDropdown.innerHTML = '<option value="">-- No projects found --</option>';
        }
    }

    function handleProjectSelection() {
        const selectedOption = projectSelectDropdown.options[projectSelectDropdown.selectedIndex];
        if (!selectedOption.value) {
            return; // User selected the placeholder
        }

        // Retrieve all necessary IDs from the selected option's data attributes
        const projectId = selectedOption.value;
        const sessionId = selectedOption.dataset.sessionId;
        const ragSessionId = selectedOption.dataset.ragSessionId;
        const projectName = selectedOption.textContent;

        console.log(`Project selected. Project ID: ${projectId}, Session ID: ${sessionId}, RAG ID: ${ragSessionId}`);

        // --- CRITICAL FIX: Update the live global variables ---
        currentProjectId = projectId;
        currentChatId = sessionId;
        currentRagId = ragSessionId;

        // Set the session storage for persistence
        setSession(sessionId, ragSessionId, projectName, projectId);
        saveState();

        // Transition the UI to the main chat view
        projectListContainer.style.display = 'none';
        mainChatContainer.style.display = 'block';
        
        // Clear the chat and add a welcome message
        chat.innerHTML = '';
        addMessage('bot', `Resumed project "${projectName}". You can continue your conversation.`);
    }
    
    function showDashboard() {
        mainChatContainer.style.display = 'none';
        dashboardContainer.style.display = 'block';
        renderDashboard();
    }

    function hideDashboard() {
        dashboardContainer.style.display = 'none';
        mainChatContainer.style.display = 'block';
    }

    async function renderDashboard() {
        dashboardContent.innerHTML = '<p>Loading projects from local file...</p>';
        try {
            // Fetch local file. Note: This requires running the HTML from a local web server (like VS Code's Live Server)
            // due to browser security policies (CORS). Opening the file directly might fail.
            const response = await fetch('projects_db.json'); 
            if (!response.ok) {
                throw new Error(`Could not load projects_db.json. Status: ${response.statusText}. Ensure it's in the same folder and you're using a local server.`);
            }
            
            const projects = await response.json(); // The file itself is the JSON array

            if (projects && projects.length > 0) {
                dashboardContent.innerHTML = ''; // Clear the loading message
                projects.forEach(project => {
                    const card = document.createElement('div');
                    card.className = 'project-card';

                    // Handle the new tiered backlog structure
                    let backlogHtml = '<h3>Backlog</h3>';
                    if (project.backlog && typeof project.backlog === 'object') {
                        const tiers = ['completed', 'tier1', 'tier2', 'tier3'];
                        let hasItems = false;
                        tiers.forEach(tier => {
                            if (project.backlog[tier] && project.backlog[tier].length > 0) {
                                hasItems = true;
                                const tierTitle = tier.charAt(0).toUpperCase() + tier.slice(1);
                                backlogHtml += `<h4>${tierTitle}</h4><ul>`;
                                backlogHtml += project.backlog[tier].map(item => `<li><b>${item.title}</b>: ${item.description}</li>`).join('');
                                backlogHtml += `</ul>`;
                            }
                        });
                        if (!hasItems) {
                            backlogHtml += '<p>No backlog items.</p>';
                        }
                    } else {
                        backlogHtml += '<p>No backlog information available.</p>';
                    }

                    card.innerHTML = `
                        <h2>${project.projectName || 'Unnamed Project'}</h2>
                        <p class="project-status">Status: ${project.status || 'N/A'}</p>
                        <p class="project-synopsis">${project.synopsis || 'No synopsis available.'}</p>
                        <div class="backlog-section">
                            ${backlogHtml}
                        </div>
                    `;
                    dashboardContent.appendChild(card);
                });
            } else {
                dashboardContent.innerHTML = '<p>No projects found in projects_db.json.</p>';
            }
        } catch (error) {
            console.error('Error rendering dashboard:', error);
            dashboardContent.innerHTML = `<p style="color: red;">Error loading dashboard: ${error.message}</p>`;
        }
    }
    
    function getVersionFromFileName() {
        try {
            const url = window.location.pathname;
            const fileName = url.substring(url.lastIndexOf('/') + 1); // e.g., "Chat_8_V7.5.html"
            
            // Return a default if the filename is unexpected
            if (!fileName || !fileName.includes('.html')) {
                return "Chat App";
            }

            // Clean up the name for display
            let displayName = fileName
                .replace('.html', '')      // Remove extension
                .replace(/_/g, ' ')        // Replace underscores with spaces
                .replace(/ V(\d)/g, ' V$1') // Ensure space before version number
                .replace(/Chat (\d)/, 'Chat $1'); // Ensure space in "Chat 8"
            
            return displayName; // e.g., "Chat 8 V7.5"
        } catch (e) {
            console.error("Could not determine version from filename:", e);
            return "Chat App"; // Fallback title
        }
    }

    function displayVersion() {
        const versionString = getVersionFromFileName();
        document.title = versionString; // Update browser tab title
        if (versionDisplay) {
            versionDisplay.textContent = versionString; // Update display element
            versionDisplay.addEventListener('click', () => {
                alert(`You are running: ${versionString}`);
            });
        }
    }

    // Add other handler functions here if they exist (e.g., handleContinueClick, handleLoadProject)

    async function populateSessionSelector() {
        try {
            const response = await fetch(LIST_PROJECTS_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'list_projects' })
            });
            if (!response.ok) { throw new Error(`Failed to fetch projects: ${response.statusText}`); }
            const data = await response.json();
            const projects = data.projects;

            // Always insert a visible placeholder and select it by default
            sessionSelect.innerHTML = '<option value="" selected>-- Switch Project --</option>';
            if (Array.isArray(projects) && projects.length > 0) {
                projects.forEach(project => {
                    const option = document.createElement('option');
                    option.value = project.project_id;
                    option.textContent = project.project_name || project.project_id;
                    option.dataset.sessionId = project.session_id || '';
                    option.dataset.ragSessionId = project.rag_session_id || '';

                    // If this project is the currently active one, select it
                    if (project.project_id === currentProjectId) {
                        option.selected = true;
                    }
                    sessionSelect.appendChild(option);
                });
            } else {
                sessionSelect.innerHTML = '<option value="" selected>-- No projects found --</option>';
            }
        } catch (error) {
            console.error('Error populating session selector:', error);
            sessionSelect.innerHTML = '<option value="" selected>-- Error loading --</option>';
        }
    }

    function handleSessionSelection() {
        const selectedOption = sessionSelect.options[sessionSelect.selectedIndex];
        if (!selectedOption.value) {
            return; // User selected the placeholder
        }

        // Retrieve all necessary IDs from the selected option's data attributes
        const projectId = selectedOption.value;
        const sessionId = selectedOption.dataset.sessionId;
        const ragSessionId = selectedOption.dataset.ragSessionId;
        const projectName = selectedOption.textContent;

        console.log(`Switching project. Project ID: ${projectId}, Session ID: ${sessionId}, RAG ID: ${ragSessionId}`);

        // Update the live global variables and persist the state
        setSession(sessionId, ragSessionId, projectName, projectId);
        saveState();

        // Manually reset the chat interface without a page reload
        chat.innerHTML = '';
        addMessage('bot', `Switched to project "${projectName}". You can continue your conversation.`);
        
        // Optional: You might want to clear the input field as well
        chatInput.value = '';
    }


    // --- STAGE 3: EVENT LISTENERS & INITIAL LOAD (Run code last) ---

    // Attach listeners to buttons
    if(createProjectButton) createProjectButton.addEventListener('click', () => { 
        startScreen.style.display = 'none';
        newProjectFormsContainer.style.display = 'block'; 
        newProjectChoiceContainer.style.display = 'block';
        newProjectSimpleDiv.style.display = 'none';
        newProjectFromUrlDiv.style.display = 'none';
        // Prepare persona dropdowns
        populatePersonaDropdown(personaSelectSimple);
        populatePersonaDropdown(personaSelectUrl);
    });

    if(continueProjectButton) continueProjectButton.addEventListener('click', handleContinueClick);
    if(projectSelectDropdown) projectSelectDropdown.addEventListener('change', handleProjectSelection);
    
    if(newProjectChoiceNo) newProjectChoiceNo.addEventListener('click', () => {
        newProjectChoiceContainer.style.display = 'none';
        newProjectSimpleDiv.style.display = 'block';
    });
    
    if(newProjectChoiceYes) newProjectChoiceYes.addEventListener('click', () => {
        newProjectChoiceContainer.style.display = 'none';
        newProjectFromUrlDiv.style.display = 'block';
    });
    
    if(createSimpleProjectButton) createSimpleProjectButton.addEventListener('click', handleCreateSimpleProject);
    if(createProjectFromUrlButton) createProjectFromUrlButton.addEventListener('click', handleCreateIndexProject);
    if(sendButton) sendButton.addEventListener('click', sendMessage);
    if(chatInput) chatInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && e.ctrlKey) {
            e.preventDefault();
            sendMessage(e);
        }
    });
    if(commitMemoryButton) commitMemoryButton.addEventListener('click', commitToMemory);
    if(clearSessionButton) clearSessionButton.addEventListener('click', handleClearSession);
    if(dashboardBtn) dashboardBtn.addEventListener('click', showDashboard);
    if(dashboardCloseBtn) dashboardCloseBtn.addEventListener('click', hideDashboard);
    if(configBtn) configBtn.addEventListener('click', openConfig);
    if(cfgCancel) cfgCancel.addEventListener('click', closeConfig);
    if(cfgSave) cfgSave.addEventListener('click', saveConfig);
    if(personaAddBtn) personaAddBtn.addEventListener('click', addPersonaRow);
    if(sessionSelect) sessionSelect.addEventListener('change', handleSessionSelection);
    
    // Initial page load sequence
    loadState();
    loadConfig();
    initializeUI();
    displayVersion();
    // Populate the project switcher dropdown regardless of view; it is harmless when hidden
    populateSessionSelector();
});

function handleClearSession() {
  console.log("Clearing session and resetting application...");
  
  // 1. Clear the browser's memory
    try {
        // Remove only session-related keys; keep custom personas and config
        const sessionKeys = [
            'lastChatId_v2',
            'lastRagId_v2',
            'lastProjectId_v2',
            'chatSessions_v2'
        ];
        sessionKeys.forEach(k => localStorage.removeItem(k));
    } catch {}
  sessionStorage.clear();
  
  // 2. Reset the live state variables to their defaults
  currentChatId = null;
  currentProjectId = null;
  currentRagId = null;
  sessions = {};
  
  // 3. Force the page to reload. It will now start fresh.
  location.reload();
}
</script>

<!-- hello Mike -->
</body>
</html>
